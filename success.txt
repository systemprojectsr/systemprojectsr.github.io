1.      Классификация типов требований. Функциональные и нефункциональные требования.

Определение требований
Требования к ИС — это совокупность характеристик, свойств и функций, которыми должна обладать система для удовлетворения ожиданий заинтересованных сторон (лиц),.

Основные классификации требований
В лекциях выделяются два ключевых подхода к классификации,:
1.  Функциональные и нефункциональные требования.
2.  Пользовательские (C-требования) и детальные/системные (D-требования).

Функциональные требования
*   Описывают конкретные функции и действия, которые продукт должен выполнять для решения задач.
*   Детализируют, что именно система «делает».

Нефункциональные требования
Описывают качественные характеристики системы и условия её работы. К ним относятся,,:
*   Ограничения: технические (вычислительные мощности, каналы связи), бюджетные ограничения проекта,,.
*   Критерии качества: производительность, объем хранимых данных, сложность запросов.
*   Внешние условия: требования законодательства, регуляторов (например, импортозамещение) и локальных нормативных актов,,.

Три уровня требований (иерархия)
Требования также разделяют по уровням проработки:
1.  Бизнес-уровень: определяется глобальными целями разработки продукта.
2.  Пользовательский уровень: отражает ожидания конечных пользователей при решении их задач.
3.  Функциональный уровень: детализирует предыдущие уровни до конкретных функций продукта.

Источники требований
Для формирования всех типов требований используются,,,:
*   Заинтересованные лица (пользователи, инвесторы, эксперты),,.
*   Нормативно-правовая база (законы, стандарты),.
*   Аналитические отчеты и исследование рынка,.
*   Внутренняя документация заказчика.

2.      Источники требований к информационным системам.

Согласно лекционным материалам, основными источниками требований к информационным системам являются:

1. Заинтересованные лица (стейкхолдеры):
*   Пользователи (конечные потребители системы).
*   Инвесторы и руководство организации.
*   Эксперты (по предметной области, эргономике, эффективности).
*   Обслуживающий и обучающий персонал.
*   Аналитики и системные архитекторы.

2. Нормативно-правовая и техническая база:
*   Законодательство и требования государственных регуляторов (например, в части импортозамещения).
*   Локальные нормативно-правовые акты предприятия-заказчика (организационные требования).
*   Государственные и отраслевые стандарты.

3. Аналитические и исследовательские материалы:
*   Отчеты по исследованию рынка.
*   Данные об инструментах конкурентов.
*   Внутренняя документация заказчика.

4. Технологические и проектные ограничения:
*   Технические условия: ограничения вычислительных мощностей, пропускная способность каналов связи и т.д..
*   Бюджет проекта: финансовые рамки, влияющие на выбор решений.

Важное замечание: Требования, полученные от разных групп заинтересованных лиц, часто могут противоречить друг другу, что требует поиска компромиссов в процессе анализа.

3.      Спецификация и документирование требований.

Согласно лекционным материалам, спецификация и документирование требований являются критически важным этапом, обеспечивающим успех ИТ-проекта в долгосрочной перспективе.

### Основные инструменты документирования требований
Для описания того, что система должна делать, используются следующие инструменты:
*   Сценарии использования (Use Cases): детальное описание последовательности действий пользователя в системе для достижения конкретной цели.
*   Пользовательские истории (User Stories): короткие описания потребностей пользователя в формате «что он хочет сделать и для чего».
*   Прототипирование: создание образцов интерфейсов (от простых макетов без функционала до работающих моделей) для получения обратной связи и уточнения требований.
*   MVP (Минимально жизнеспособный продукт): версия продукта с ограниченной функциональностью для проверки гипотез и сбора отзывов.

### Спецификация с помощью UML-диаграмм
В объектно-ориентированном проектировании требования документируются через визуальные модели:
1.  Диаграммы вариантов использования: выделение процессов предметной области и внешней среды.
2.  Диаграммы объектов: описание концептуальной модели через понятия, атрибуты и ассоциации.
3.  Диаграммы взаимодействия (последовательности): описание логики обмена сообщениями между компонентами.
4.  Диаграммы классов: фиксация методов, связей и структуры классов.

### Автоматизация документирования (CASE-средства)
Использование специализированных инструментов (CASE-средств) позволяет:
*   Создавать базы данных требований и определять их атрибуты.
*   Формировать матрицы и деревья трассировки для отслеживания связей между требованиями.
*   Представлять требования в иерархическом, табличном или древовидном виде для удобства фильтрации и модификации.

### Правила эффективного документирования
Для снижения рисков (неполноты или нечеткости формулировок) необходимо:
*   Детально документировать все требования с пояснениями и примерами.
*   Использовать язык предметной области.
*   Соблюдать процедуру подтверждения и согласования требований с ответственными лицами и конечными пользователями.
*   Вести каталог требований с указанием статуса каждого элемента.

4.      Определение и область применения быстрого прототипирования.

Согласно лекционным материалам, основные сведения о быстром прототипировании для экзамена:

Определение
Быстрое прототипирование — это методика создания макета пользовательского интерфейса, который не обладает реальной функциональностью,. 

Область применения
1.  Ранние стадии проекта: макет используется как материал для беседы с заинтересованными лицами («talking point») для обсуждения внешнего вида и удобства системы,.
2.  Поздние стадии проекта: применяются прототипы, включающие некоторую функциональность, для уточнения и детализации требований.
3.  Получение обратной связи: образцы интерфейсов позволяют оперативно получить отзывы пользователей по будущему продукту,.
4.  Проверка гипотез: в рамках концепции MVP (минимально жизнеспособного продукта) прототипирование помогает быстро проверить рабочие гипотезы с минимальными затратами ресурсов,.

5.      Характеристики уровней требований (бизнес, пользовательский, функциональный).

Согласно лекционным материалам, требования к информационной системе разделяются на три иерархических уровня:

1.  Бизнес-уровень: определяется глобальными целями разработки программного продукта. Он описывает, зачем организации нужна эта система и какую пользу она принесет бизнесу.
2.  Пользовательский уровень (C-требования): отражает ожидания конечных пользователей от системы при решении их конкретных задач в рамках выполняемых работ. Этот уровень описывает, что пользователь сможет делать с помощью продукта.
3.  Функциональный уровень (D-требования или детальные/системные): детализирует первые два уровня до описания конкретных функций продукта. Он определяет действия, которые система должна выполнять для удовлетворения пользовательских потребностей.

6.      Способы минимизации рисков при разработке требований.

Согласно лекционным материалам, основными рисками при разработке требований являются их неполнота, нечеткость формулировок и изменчивость на протяжении проекта.

Для минимизации этих рисков применяются следующие способы:

*   Многократное подтверждение и согласование: внедрение четкой процедуры утверждения требований и любых изменений в них с ответственными лицами.
*   Активное участие пользователей: вовлечение конечных пользователей непосредственно в процесс анализа и утверждения требований.
*   Детальное документирование: фиксация всех требований с включением подробных пояснений, примеров и пользовательских историй (User Stories).
*   Ведение каталога требований: использование структурированного каталога с обязательным указанием статуса каждого элемента.
*   Прототипирование и MVP: 
    *   Создание быстрых прототипов (макетов интерфейса) как материала для обсуждения («talking point») на ранних стадиях.
    *   Разработка MVP (минимально жизнеспособного продукта) для оперативной проверки гипотез и сбора реальных отзывов.
*   Использование CASE-средств: автоматизация работы с требованиями, создание матриц и деревьев трассировки для отслеживания связей между ними.
*   Эффективные методы сбора данных: 
    *   Проведение интервью (минимум двумя членами команды разработки) с обсуждением сценариев использования и потоков данных.
    *   Организация фокус-групп для получения аналитики о потребностях и впечатлениях от прототипа.
*   Архитектурное описание: использование моделей архитектуры как общего языка общения между заинтересованными сторонами для снижения рисков ошибок и сбоев.

7.      Категорирование заинтересованных лиц при разработке требований.

Согласно лекционным материалам, категорирование заинтересованных лиц (стейкхолдеров) необходимо для систематизации сбора требований и обеспечения полноты охвата всех аспектов системы.

Критерии классификации заинтересованных лиц:
*   По привилегиям доступа и уровням информационной безопасности.
*   По выполняемым задачам (бизнес-функциям).
*   По частоте использования продукта.
*   По опыту работы (квалификация пользователя).
*   По виду доступа к системе.
*   По используемой аппаратной платформе.

Основные группы заинтересованных сторон:
1.  Пользователи: конечные потребители, решающие свои задачи в рамках работы.
2.  Инвесторы и руководство: определяют глобальные бизнес-цели и бюджет проекта.
3.  Эксперты: специалисты по предметной области, эргономике и эффективности.
4.  Обслуживающий и обучающий персонал: сотрудники, отвечающие за внедрение и поддержку ИС.
5.  Регуляторы: государственные органы или организации, устанавливающие стандарты и законодательные требования.

Роли в рамках архитектурного описания (Фреймворк Захмана):
На разных уровнях проектирования выделяются специфические группы стейкхолдеров:
*   Аналитики (уровень контекста);
*   Руководство организации (бизнес-модель);
*   Системные архитекторы (системная модель);
*   Разработчики (технологическая модель);
*   Системные администраторы (детальное описание);
*   Конечные пользователи (функционирующая организация).

Важные принципы работы с категориями стейкхолдеров:
*   Представительство: из каждого выделенного класса необходимо выбрать представителя для организации контактов и сбора требований.
*   Конфликт интересов: требования от разных групп часто противоречат друг другу, что требует поиска компромиссов со стороны руководителя проекта.

8.      Методы сбора требований (анкетирование, наблюдение, фокус-группы, семинары).

Согласно лекционным материалам, выделяют следующие основные методы сбора требований:

*   Анкетирование (опросные листы): Применяется для получения информации от больших групп пользователей,. Считается одним из лучших способов при условии его правильной организации,.
*   Наблюдение: Аналитик присутствует при выполнении пользователем его трудовых функций и бизнес-операций,. Может быть пассивным или активным (когда аналитик задает уточняющие вопросы в процессе работы),.
*   Фокус-группы: Организация сессий коллективного обсуждения (интерактивных встреч), где участники делятся мнениями об ожиданиях от системы и впечатлениями от использования прототипов,,. Главная проблема метода — обеспечение представительности группы.
*   Интервьюирование: Прямое общение с заинтересованными лицами,. В процессе интервью обязательно обсуждаются варианты использования, потоки данных и диаграммы переходов; на встрече рекомендуется присутствие минимум двух членов команды разработки.
*   Работа с прототипами: Создание макетов интерфейса. На ранних стадиях используется «быстрое прототипирование» (макет без функционала) как материал для беседы («talking point»), на поздних — прототип с функционалом для уточнения деталей,.
*   Раскадровка (storyboarding): Графическое описание работы системы (с использованием графиков, презентаций, анимации) для визуализации типовых сценариев использования.
*   Обыгрывание ролей: Метод, при котором разработчик пытается сыграть роль пользователя (требует наличия готовых пользовательских историй или вариантов использования).

9.      Определение архитектуры информационных систем. Различные подходы к определению архитектуры.

Архитектура ИС
Архитектура - представляет собой высокоуровневое представление структуры поведения и организации системы. Архитектура определяет взаимодействие ключевых компонентов сервисов и интерфейсов. Обеспечивая надежность, эффективность функционирования системы.

Архитектура - это набор значимых решений по поводу ораганизации сис прог обесп, набор структурных элементов и их интерфейсов, при помощи которых компонуется система вместе с их поведением, компоновка элементов в постепенно укрупняющиеся подсистемы, а также стиль архитектуры, который направляет эту организацию.

Архитектура - это набор ключевых решений неизменных при изменении бизнес-технологий в рамках бизнес-видения.

10.   Преимущества архитектурного описания для проекта информационной системы.

Зачем проектируют архитектуру?
1. Архитектурное описание может использоваться как язык общения между заинтересованными сторонами как в процессе проектирования, так и в процессе эксплуатации.
2. Может использоваться для генерации кода в приложении.
3. Может использоваться при проектировании линейки или семейства продуктов, что позволяет уменьшить стоимость разработки и уменьшает риски.

Согласно лекционным материалам, архитектурное описание является высокоуровневым представлением структуры и организации системы, которое дает проекту следующие ключевые преимущества:

*   Средство коммуникации: служит общим «языком общения» между всеми заинтересованными сторонами (стейкхолдерами) как на этапе проектирования, так и в процессе эксплуатации,.
*   Снижение рисков и затрат: позволяет проектировать не отдельные продукты, а целые линейки (семейства) программных решений, что существенно уменьшает стоимость разработки и минимизирует проектные риски,.
*   Техническая стабильность и надежность: минимизирует риск возникновения сбоев и ошибок, а также обеспечивает общую согласованность и устойчивость функционирования системы,,.
*   Упрощение сопровождения: наличие четкого описания значительно облегчает дальнейшую поддержку, развитие и модификацию проекта,.
*   Автоматизация разработки: архитектурные модели могут использоваться для автоматической генерации программного кода,.
*   Борьба со сложностью: является основной стратегией декомпозиции сложных систем, позволяя снизить общую сложность больших ИТ-проектов,.
*   Повышение качества: использование архитектурных стандартов и моделей (например, UML) позволяет создавать эффективные и надежные решения, повышая качество всего процесса разработки,.

11.   Доменный подход при классификации архитектуры информационных систем.

Согласно лекционным материалам, доменный подход предполагает классификацию архитектуры ИС на верхнем уровне по двум ключевым типам доменов:,

1.  Домены задач — определяют цели предметной области и задачи, которые должна решать система,.
2.  Домены решений — описывают способы технической реализации системы. Они включают в себя:,
    *   Программную архитектуру (характеризуется архитектурными стилями и способами реализации),.
    *   Техническую архитектуру,.

Важные характеристики в рамках домена решений:
На уровне программной архитектуры анализируются:
*   Архитектурные стили (например, клиент-серверные, микросервисные, объектно-ориентированные системы и др.),.
*   Способы реализации, которые могут быть монолитными или многомодульными,.

12.   Техническая и программная архитектура информационных систем.

Согласно лекционным материалам, программная и техническая архитектуры являются составляющими домена решений и занимают нижние уровни в пятиуровневой модели (пирамиде) архитектуры ИС.

### Программная архитектура (4 уровень)
Отображает совокупность приложений и детальное архитектурное описание каждого из них.

*   Способы реализации:
    *   Монолитное приложение — единая неделимая структура.
    *   Многомодульное приложение — состоит из отдельных модулей, которые могут быть представлены как объекты, компоненты, веб-службы, облачные сервисы или агенты.
*   Способы интеграции модулей: вызов удаленных процедур (RPC), очереди сообщений, общие базы данных и файлы, бизнес-процессы.
*   Архитектурные стили: клиент-серверные, объектно-ориентированные, микросервисные, иерархические многоуровневые, системы управляемые событиями, «конвейеры и фильтры» и другие.
*   Микросервисный подход: приложение строится как набор небольших независимых сервисов, которые взаимодействуют через простые механизмы и могут развертываться отдельно.

### Техническая архитектура (5 уровень)
Характеризует аппаратные и сетевые средства, обеспечивающие работу системы.

*   Назначение: создание среды и инфраструктуры для реализации программных приложений.
*   Ключевые технологии и концепции:
    *   SDS (Программно-определяемое хранилище): объединение простых систем в кластеры с помощью ПО, что обеспечивает независимость логики хранения от физического оборудования.
    *   Виртуализация: процесс работы нескольких ОС на одном аппаратном обеспечении через гипервизор для повышения эффективности мощностей.
    *   Контейнеризация: изоляция процессов с использованием общего ядра ОС, что снижает накладные расходы по сравнению с полной виртуализацией.
    *   Сетевая инфраструктура: архитектура сетей и каналов связи, обеспечивающая взаимодействие распределенных узлов.

Важный аспект (Чистая архитектура): С точки зрения «чистой архитектуры», конкретные базы данных и технические детали должны быть независимы от бизнес-правил и восприниматься как низкоуровневые утилиты.

13.   Особенности архитектурного стиля «конвейеры и фильтры».

Согласно лекционным материалам, архитектурный стиль «конвейеры и фильтры» (Pipes and Filters) имеет следующие ключевые особенности:

Суть и структура
*   Декомпозиция: Процесс обработки данных разбивается на ряд отдельных, автономных компонентов — фильтров.
*   Фильтры: Каждый фильтр выполняет строго определенную задачу. Он получает сообщение из входящего канала, обрабатывает или проверяет его и публикует в исходящий канал.
*   Каналы (конвейеры): Соединяют фильтры между собой, передавая выходные данные одного фильтра в качестве входных для следующего.

Ключевые свойства
*   Независимость: Фильтры автономны и «не знают» о существовании других фильтров в системе. Им известны только их собственные входные и выходные схемы данных.
*   Гибкость: Фильтры можно упорядочивать в любом порядке, если входная схема текущего фильтра соответствует выходной схеме предыдущего.
*   Масштабируемость: Шаги обработки можно распределять между несколькими разными серверами.

Область применения
Этот стиль рекомендуется использовать, когда:
1.  Процесс обработки данных легко делится на независимые этапы.
2.  Требуется возможность гибко переупорядочивать шаги обработки.
3.  Необходимо распределить нагрузку между серверами.

Ограничения
Стиль будет неэффективен, если этапы обработки зависимы друг от друга или должны выполняться строго вместе в рамках одной транзакции.

14.   Определение «микросервиса».

Согласно лекционным материалам, определение и ключевые характеристики микросервисов для экзамена:

Определение
Микросервисы — это подход к разработке программного обеспечения или архитектура, при которой приложение строится как набор небольших, слабосвязанных сервисов, каждый из которых работает в своем процессе и общается с другими с помощью простых механизмов,. 

Под сервисом понимается любая дискретная (конечная) функция или набор функций, образующих бизнес-процесс, которые предлагаются внешнему потребителю,.

Ключевые характеристики
Согласно источникам, систему относят к микросервисной архитектуре по следующим признакам,,,:
*   Автономность: каждый микросервис независим при развертывании и масштабировании.
*   Отсутствие монолитности: каждый модуль ориентирован на решение конкретной бизнес-задачи и имеет четко определенный интерфейс.
*   Отсутствие иерархии: все сервисы работают на одном уровне.
*   Взаимодействие: модули взаимодействуют между собой по принципу «каждый с каждым».
*   Технологическая независимость: разные микросервисы могут разрабатываться разными командами на разных языках программирования и платформах.

Свойства сервисов
*   Являются многократно используемыми бизнес-функциями,.
*   Определяются через формальные интерфейсы, не зависящие от реализации,.
*   Инвариантны по отношению к языку и платформе при обращении к ним,.

15.   Архитектурные фреймворки. Фреймворк Захмана.

Согласно лекционным материалам, ниже представлены основные положения о фреймворке Захмана для подготовки к экзамену:

Определение и суть
Фреймворк Захмана — это матричная модель, основанная на идее, что функционирование организации можно полностью описать, ответив на 6 базовых вопросов, рассматриваемых с 6 точек зрения различных заинтересованных сторон,.

Структура матрицы (6 вопросов — колонки)
Каждая колонка соответствует определенному аспекту системы:
1.  Что? (Данные: от списка сущностей до физических данных),.
2.  Как? (Функции: от бизнес-процессов до исполняемого кода),.
3.  Где? (Сеть: от размещения организации до сетевой инфраструктуры),.
4.  Кто? (Люди: от внешних организаций до ролей и прав доступа),.
5.  Когда? (Время: от графиков работ до истории функционирования),.
6.  Почему? (Мотивация: от бизнес-стратегии до реализуемых стратегий),.

Уровни описания и роли (6 строк)
Каждая строка представляет описание системы с точки зрения конкретной группы заинтересованных лиц,:
1.  Уровень контекста — Аналитики,.
2.  Бизнес-модель — Руководство организации,.
3.  Системная модель — Системные архитекторы,.
4.  Технологическая модель — Разработчики,.
5.  Детальное описание — Системные администраторы,.
6.  Функционирующая организация — Конечные пользователи,.

Основные правила заполнения
*   Уникальность: Каждая ячейка уникальна и содержит описание аспекта реализации в виде конкретной модели или документа,.
*   Собственная модель: Каждой колонке соответствует своя специфическая модель,.
*   Последовательность: Заполнение ячеек должно проводиться строго последовательно сверху вниз,.

16.   Основная идея структурного анализа и проектирования.

Согласно лекционным материалам, основная идея структурного анализа и проектирования заключается в следующем:

*   Суть подхода: Декомпозиция (разделение) общей задачи на отдельные функции и процессы.
*   Результат: Создание иерархии процессов и подпроцессов.
*   Цель: Использование декомпозиции как основной стратегии борьбы со сложностью программных проектов ИС (этот подход преобладал до появления объектно-ориентированного проектирования).
*   Пример: При структурном подходе в библиотечной системе выделяются конкретные функции, такие как «заполнить формуляр», «добавить ресурсы» или «составить отчет».

17.   Основная идея объектно-ориентированного анализа и проектирования.

Согласно лекционным материалам, основная идея и ключевые аспекты объектно-ориентированного анализа и проектирования (ООАП) заключаются в следующем:

### Суть подхода
Основная идея ООАП состоит в рассмотрении предметной области и логического решения задачи с точки зрения объектов — понятий или сущностей. В отличие от структурного подхода, который делит задачу на функции, ООАП использует объектную декомпозицию как главную стратегию борьбы со сложностью ИС.

### Разделение на анализ (ООА) и проектирование (ООП)
1.  Объектно-ориентированный анализ (ООА): основное внимание уделяется определению и описанию объектов или понятий в терминах предметной области.
2.  Объектно-ориентированное проектирование (ООП/OOD): определяются логические программные объекты, которые будут реализованы средствами языков программирования. Эти объекты включают в себя конкретные атрибуты и методы.

### Сравнение со структурным подходом (на примере библиотеки)
*   Структурный подход: выделяет функции (например: «заполнить формуляр», «составить отчет»).
*   Объектный подход: выделяет объекты (например: «Каталог», «Библиотекарь», «Книга»).

### Этапы проектирования в нотации UML
Процесс включает четыре последовательных шага:
1.  Выделение процессов: описание внешней среды и функций через прецеденты (диаграммы вариантов использования).
2.  Определение концептуальной модели: декомпозиция предметной области, идентификация атрибутов и ассоциаций (диаграммы объектов).
3.  Составление диаграмм взаимодействия: распределение обязанностей между объектами через обмен сообщениями (диаграммы последовательности).
4.  Составление диаграммы классов: определение связей и методов для окончательной структуры системы.

### Главная цель и преимущества
*   Переносимость: создание переносимых и типовых решений для разработки ИС.
*   Гибкость: модульность, легкость поддержки и возможность повторного использования кода.

Основные постулаты: всё в системе является объектом; вычисления производятся путем обмена данными между объектами; каждый объект имеет собственную память и является экземпляром класса.

18.   Основные понятия объектно-ориентированного подхода. Классы и объекты.

Согласно лекционным материалам, основные сведения об объектно-ориентированном подходе (ООП), классах и объектах для подготовки к экзамену включают следующее:

### Суть объектно-ориентированного подхода
Основная идея заключается в рассмотрении предметной области и логического решения задачи с точки зрения объектов — понятий или сущностей,. Объектная декомпозиция является главной стратегией борьбы со сложностью информационных систем,. 

### Классы и объекты: определения
*   Класс — это абстрактный шаблон, определяющий свойства и поведение объектов,. Это описание набора объектов, разделяющих одни и те же атрибуты и семантику.
*   Объект — это конкретный экземпляр класса с определёнными значениями свойств,. Каждый объект является представителем своего класса и обладает собственной памятью,.

### Внутренняя структура класса
1.  Атрибут — поименованный участок внутри класса, описывающий интервал значений, которые могут содержать экземпляры.
2.  Операция — служба, которую можно запросить у объекта, чтобы повлиять на его поведение.
3.  Метод — конкретная реализация операции (алгоритм или процедура).

### Фундаментальные понятия ООП
*   Наследование — механизм расширения функциональности путём создания подклассов,.
*   Полиморфизм — способность объектов одной иерархии реагировать на одинаковые запросы по-разному,.
*   Инкапсуляция (степень обособленности) — отсутствие соединения базы данных или кода с внешними элементами, обеспечивающее завершенность программного интерфейса.

### Основные постулаты (идеи) ООП
*   Всё в системе является объектом,.
*   Вычисления производятся путём обмена данными между объектами,.
*   Класс задает поведение объекта; все экземпляры одного класса могут выполнять одни и те же действия,.

### Преимущества и недостатки
*   Преимущества: создание переносимых решений, модульность, повторное использование кода, гибкость и расширяемость программ,,,.
*   Недостатки: сложность освоения принципов и потенциальное снижение производительности из-за накладных расходов на управление объектами,.

19.   Принципы инкапсуляции, наследования и полиморфизма в объектно-ориентированном подходе.

Согласно лекционным материалам, три фундаментальных принципа объектно-ориентированного подхода (ООП) определяются следующим образом:

1.  Наследование
    *   Это механизм расширения функциональности системы путём создания подклассов.
    *   В UML этот принцип реализуется через генерализацию — таксономическое отношение между общим и специфическим элементом, где специфический элемент содержит дополнительную информацию, оставаясь однородным с общим.
    *   Наследование позволяет легче использовать классы повторно.

2.  Полиморфизм
    *   Это способность объектов одной иерархии реагировать на одинаковые запросы (вопросы) по-разному.
    *   Он обеспечивает гибкость, позволяя системе взаимодействовать с объектами разных типов через единый интерфейс.

3.  Инкапсуляция
    *   Определяется как степень обособленности (изоляции) элементов системы и завершенность её программного интерфейса.
    *   Основная цель — отсутствие прямых соединений базы данных или кода с внешними элементами других систем, что обеспечивает автономность модуля.
    *   Для реализации этого принципа в классах задается видимость (общедоступная, защищенная или скрытая) для атрибутов и операций.

Значимость принципов для разработки:
Соблюдение этих принципов (включая принципы SOLID) позволяет создавать устойчивые, расширяемые и переносимые программные решения, снижая общую сложность проектов ИС.

20.   Исторические предпосылки появления объектно-ориентированной методологии.

Согласно лекционным материалам, основными историческими предпосылками появления объектно-ориентированной методологии (ООП/ООАП) являются:

*   Рост сложности программных проектов: По мере усложнения ИС потребовалась более эффективная стратегия «борьбы со сложностью», чем существовавший ранее структурный анализ.
*   Ограниченность структурного подхода: Декомпозиция задач исключительно на функции и процессы перестала удовлетворять потребностям разработки масштабных систем.
*   Проблема непереносимости программ: В конце 1970-х — начале 1980-х годов (например, в МИИГАиК) существующие программы были жестко привязаны к конкретным компьютерным системам и не могли быть перенесены на другие платформы.
*   Высокая трудоемкость модификации: Внесение даже незначительных изменений в существующий программный код (например, замена вопросов в тестах) требовало чрезмерных затрат ресурсов.
*   Потребность в типовых решениях: Главной целью появления ООП было создание переносимых решений, что в дальнейшем позволило перейти к типовому проектированию и разработке ИС.

Итог для экзамена: Объектный подход возник как ответ на кризис переносимости и поддержки программ, заменив функциональную декомпозицию более гибкой — объектной декомпозицией.

21.   Преимущества и недостатки объектно-ориентированного подхода.

Объектно-ориентированный подход (ООП) имеет следующие ключевые характеристики для экзаменационного ответа:

### Преимущества ООП:
*   Модульность и повторное использование кода: позволяет использовать одни и те же наработки в разных проектах, что упрощает разработку,.
*   Переносимость решений: методология создавалась для разработки программ, которые можно легко переносить на другие системы,.
*   Гибкость и расширяемость: программные продукты легче адаптировать под новые требования без полной переработки кода,.
*   Упрощение поддержки и тестирования: легче вносить изменения и проверять работоспособность отдельных изолированных частей системы,.
*   Автоматическая нормализация данных: при проектировании баз данных использование объектного подхода (UML-диаграмм) позволяет почти автоматически устранить большинство зависимостей и создать оптимизированную структуру таблиц,.

### Недостатки ООП:
*   Сложность освоения: понимание и правильное применение принципов объектного проектирования требует значительных усилий,.
*   Снижение производительности: управление объектами создает дополнительные накладные расходы, что может замедлять работу системы по сравнению с простыми скриптами (например, bash-скрипт против системы мониторинга Zabbix),.
*   Трудности описания предметной области: объекты должны быть описаны на языке заказчика, однако в предметной области часто отсутствует четкий глоссарий, что затрудняет проектирование,.

22.   Перечислите и подробно опишите принципы «SOLID».

Согласно лекционным материалам, SOLID — это акроним пяти фундаментальных принципов разработки программного обеспечения, направленных на создание устойчивых, поддерживаемых и легко расширяемых программ,,.

Ниже приведено описание каждого принципа:

1.  S — Single Responsibility Principle (Принцип единственной ответственности): Каждый класс должен иметь одну ответственность и решать только одну конкретную задачу,.
2.  O — Open/Closed Principle (Принцип открытости/закрытости): Программные сущности (включая классы) должны быть открыты для расширения, но закрыты для модификации. Новые возможности должны появляться путём добавления новых классов, а не изменения уже существующего кода,.
3.  L — Liskov Substitution Principle (Принцип подстановки Лисков): Подкласс должен заменять базовый класс таким образом, чтобы его можно было использовать без нарушения работоспособности всей системы,.
4.  I — Interface Segregation Principle (Принцип разделения интерфейса): Интерфейсы должны быть узкими и специализированными. Программные компоненты не должны зависеть от методов интерфейсов, которые они не используют,.
5.  D — Dependency Inversion Principle (Принцип инверсии зависимостей): Высокоуровневые модули не должны зависеть от низкоуровневых. Оба типа модулей должны зависеть от абстракций (примером нарушения этого принципа в лекциях называется старая программа для тестирования, где модули были жестко связаны),.

Применение этих принципов совместно с паттернами проектирования и моделями UML позволяет повысить качество процесса разработки и создавать надежные ИС,.

23.   Основные функции CASE-средств, используемых при проектировании информационных систем.

Согласно лекционным материалам, основная функциональность CASE-средств (Computer-Aided Software Engineering) при проектировании информационных систем включает:

1. Работа с требованиями:
*   Создание баз данных требований, определение их типов и атрибутов.
*   Создание иерархии требований и их связывание со сценариями использования (Use Cases).
*   Формирование матриц и деревьев трассировки для отслеживания связей между требованиями.
*   Визуализация требований в табличном или древовидном виде для удобной фильтрации и модификации.

2. Проектирование и моделирование:
*   Проектирование баз данных через предварительное создание моделей классов и сущностей.
*   Использование графических нотаций (например, UML) для описания структуры и поведения системы.

3. Автоматизация реализации и контроля:
*   Автоматическая генерация программного кода и SQL-запросов на основе созданных моделей.
*   Синхронизация CASE-моделей с физическими базами данных для выявления расхождений.
*   Контроль состояния объектов БД и актуализация документации после внесения изменений.

Преимущества использования: Сокращение времени разработки, повышение качества проектных решений и упрощение последующего сопровождения системы.

24.   Диаграммы UML в объектно-ориентированном анализе и проектировании.

Согласно лекционным материалам, в объектно-ориентированном анализе и проектировании (ООАП) нотация UML используется как основная стратегия борьбы со сложностью ИС.

Процесс проектирования включает четыре основных этапа, на каждом из которых применяются специфические диаграммы:

1.  Выделение процессов предметной области и внешней среды:
    *   Диаграмма: Вариантов использования (Use Case Diagrams).
    *   Цель: Описание действий пользователя для достижения определенных целей и определение границ системы.

2.  Определение концептуальной модели:
    *   Диаграмма: Объектов (Object Diagrams).
    *   Цель: Декомпозиция предметной области через идентификацию понятий (сущностей), их атрибутов и ассоциаций.

3.  Составление диаграмм взаимодействия:
    *   Диаграммы: Последовательности (Sequence Diagrams), кооперации и другие.
    *   Цель: Распределение обязанностей между объектами и иллюстрация их взаимодействия посредством обмена сообщениями.

4.  Составление диаграммы классов:
    *   Диаграмма: Классов (Class Diagrams).
    *   Цель: Определение окончательной структуры системы: как объекты связаны друг с другом и какие методы (операции) закреплены за каждым классом.

### Применение UML при проектировании баз данных
UML также используется для отображения объектных моделей в таблицы реляционных БД:
*   Классы используются со стереотипами `«table»` (таблица), `«view»` (представление), `«schema»` (схема).
*   Атрибуты представляют столбцы таблиц с типами данных.
*   Операции классов со стереотипами `«pk»` (первичный ключ), `«fk»` (внешний ключ), `«index»` и `«uniq»` используются для описания ограничений целостности.
*   Отношения: Ассоциация, агрегация (неидентифицирующая связь) и композиция (идентифицирующая связь).

Использование UML-моделей позволяет автоматизировать генерацию SQL-запросов и программного кода, а также синхронизировать проектную модель с физической базой данных.

25.   Понятие «шаблона (паттерна) проектирования».

Согласно лекционным материалам, основные сведения о шаблонах (паттернах) проектирования для экзамена:

Определение и суть
*   Шаблон (паттерн) проектирования — это проверенное решение распространенной проблемы, возникающей при проектировании программного обеспечения.
*   По сути, это набор абстрактных классов, ориентированных на решение задач в определенном домене.
*   Паттерны позволяют выделить часто встречающиеся проблемы, дать им имена и предложить типовые решения для внедрения в информационные системы.

Классификация по уровням (типам)
1.  Концептуальные паттерны: описываются в терминах предметной области и относятся к приложению в целом или крупным подсистемам.
2.  Паттерны проектирования: используют термины разработки (объект, класс, модуль) и описывают решения общих проблем в конкретном контексте.
3.  Программные паттерны: описывают решения на уровне структур данных (деревья, списки и т.д.).

Группы паттернов проектирования
*   Системные: представляют приложение на верхнем уровне (например, MVC — разделение на модель, представление и контроллер).
*   Структурные: отвечают за компоновку элементов (например, Адаптер, Фасад, Декоратор).
*   Поведенческие: применяются для передачи управления и взаимодействия объектов (например, Наблюдатель, Команда, Медиатор).
*   Производящие и паттерны параллельного программирования.

Описание и применение
*   Для описания паттерна используется стандартный шаблон: назначение, мотивация, условия применения, структура, пример кода и результаты.
*   Анти-паттерны (ловушки): это наиболее часто внедряемые плохие решения, которых следует избегать в практике программирования (например, «Божественный объект», «Спагетти-код»).
*   Использование паттернов (совместно с принципами SOLID и моделями UML) повышает качество разработки и позволяет создавать надежные и эффективные решения.

26.   Классификация шаблонов (паттернов) проектирования.

Согласно лекционным материалам, шаблоны (паттерны) проектирования — это проверенные решения распространенных проблем проектирования ПО, которые классифицируются по нескольким признакам.

### 1. Классификация по уровню абстракции
Выделяют три основных типа паттернов:
*   Концептуальные паттерны: описываются в терминах предметной области. Они относятся к приложению в целом или его крупным подсистемам.
*   Паттерны проектирования: описываются в терминах разработки программных систем (объект, класс, модуль). Решают общие задачи в конкретном контексте.
*   Программные паттерны: описывают решения на уровне низкоуровневых структур данных (деревья, списки и т.д.).

### 2. Классификация по функциональному назначению
*   Системные паттерны: представляют приложение на верхнем уровне или поддерживают его разные части.
    *   *Примеры:* MVC (Модель-Вид-Контроллер) для разделения логики, представления и управления; Транзакция.
*   Структурные паттерны: отвечают за компоновку элементов и взаимодействие интерфейсов.
    *   *Примеры:* Адаптер (совмещение несовместимых интерфейсов), Мост, Декоратор, Фасад.
*   Поведенческие паттерны: применяются для организации взаимодействия и передачи управления между объектами.
    *   *Примеры:* Команда, Наблюдатель, Медиатор.
*   Производящие паттерны: отвечают за механизмы создания объектов.
*   Паттерны параллельного программирования: для управления потоками и ресурсами в многопоточных средах.

### 3. Анти-паттерны (ловушки)
Отдельно выделяют анти-паттерны — это наиболее часто внедряемые плохие решения, которых следует избегать. Они делятся на группы: в области ООП (например, «Божественный объект»), программирования («Спагетти-код»), методологии («Изобретение колеса») и организационные («Единственный знающий человек»).

27.   Основная цель использования шаблонов проектирования.

Согласно лекционным материалам, основной целью использования шаблонов (паттернов) проектирования является предоставление проверенных и типовых решений для часто встречающихся проблем, возникающих при проектировании программного обеспечения.

Основные задачи использования паттернов для проекта:
*   Унификация: паттерны позволяют выделить типовые проблемы, «дать им имена» и предложить стандартные способы их решения.
*   Повышение качества: применение шаблонов позволяет создавать более надежные, эффективные и устойчивые программные решения.
*   Снижение затрат и рисков: использование готовых архитектурных наработок позволяет уменьшить стоимость разработки и минимизировать риски сбоев.
*   Повторное использование и переносимость: создание переносимых решений, что обеспечивает переход к типовому проектированию информационных систем.
*   Упрощение сопровождения: паттерны делают структуру системы более понятной, упрощая её поддержку, тестирование и дальнейшее развитие.

28.   Описание и назначение шаблона проектирования «модель-представление-контроллер».

Согласно лекционным материалам, Модель-Вид-Контроллер (MVC) — это системный паттерн, разделяющий приложение на три логические части для облегчения их модификации и тестирования,.

Назначение шаблона:
*   Реализация принципа разделения задач (запросов, логики и отображения).
*   Обеспечение возможности независимого создания и тестирования бизнес-логики (модели) от её визуального представления.
*   Использование при разработке API-приложений и веб-интерфейсов.

Описание компонентов:
1.  Модель (Model):
    *   Представляет состояние приложения, содержит бизнес-логику и выполняемые операции.
    *   Является независимым компонентом: не знает о контроллере и представлении.
2.  Представление (View):
    *   Отвечает за отображение содержимого через пользовательский интерфейс.
    *   Должно содержать минимальную логику, связанную только с визуализацией данных.
    *   Зависит от модели.
3.  Контроллер (Controller):
    *   Управляет взаимодействием с пользователем: принимает запросы, работает с моделью и выбирает подходящее представление для ответа.
    *   Контролирует, как именно приложение реагирует на конкретный запрос.
    *   Зависит от модели.

Механизм работы:
Запросы пользователя всегда направляются в контроллер. Он взаимодействует с моделью для выполнения действий или получения данных, после чего выбирает представление для вывода результата пользователю.

29.   Описание и назначение шаблона проектирования «адаптер».

Согласно лекционным материалам, основные сведения о шаблоне проектирования «Адаптер» для экзамена:

*   Тип паттерна: относится к группе структурных паттернов.
*   Назначение: обеспечивает взаимодействие двух классов или систем путем преобразования интерфейса одного из них таким образом, чтобы им мог пользоваться другой класс.

Основные определения (суть работы):
1.  Преобразование интерфейса: адаптер преобразует интерфейс одного класса в интерфейс, ожидаемый другим классом.
2.  Интеграция систем: он обеспечивает возможность двум несовместимым системам обмениваться информацией.
3.  Обеспечение взаимодействия: основная задача — сделать так, чтобы классы с различными интерфейсами могли работать совместно.

30.   Описание и назначение шаблона проектирования «наблюдатель».

Согласно лекционным материалам, основные сведения о шаблоне проектирования «Наблюдатель» (Observer):

*   Тип паттерна: Относится к группе поведенческих паттернов, которые применяются для передачи управления в системе.
*   Назначение: Устанавливает связь между наблюдателями и наблюдаемым объектом.

Суть работы:
Шаблон позволяет реализовать механизм, при котором один объект (наблюдаемый) автоматически уведомляет всех подписанных на него участников (наблюдателей) об изменениях своего состояния. Это обеспечивает гибкое взаимодействие объектов без необходимости их жесткой привязки друг к другу.

31.   Опишите известные вам антипаттерны проектирования информационных систем.

Согласно лекционным материалам, антипаттерны (ловушки) — это классы наиболее часто внедряемых плохих решений, которых следует избегать в практике проектирования и программирования.

Основные группы антипаттернов:

### 1. Антипаттерны в области ООП
*   Божественный объект (God Object): концентрация слишком большого количества функций в одном классе.
*   Полтергейст: объект, чье единственное назначение — передавать информацию другим объектам.

### 2. Антипаттерны в области программирования
*   Спагетти-код: код с чрезмерно запутанным и сложным порядком выполнения.
*   Таинственный код: использование аббревиатур вместо понятных (мнемоничных) имен.
*   Лодочный якорь: сохранение в системе частей кода, которые больше не используются.
*   Ненужная сложность: внесение избыточной сложности в решение задачи.

### 3. Антипаттерны разработки и проектирования ПО
*   Большой комок грязи: система с нераспознаваемой (хаотичной) структурой.
*   Бензиновая фабрика: необязательная, избыточная сложность дизайна системы.
*   Магическая кнопка: выполнение результатов действий пользователя в неподходящем интерфейсе.
*   Дымоход: сборка системы из плохо связанных между собой компонентов.

### 4. Методологические антипаттерны
*   Программирование методом копирования и вставки: дублирование и легкая модификация кода вместо создания общих решений.
*   Золотой молоток: слепая уверенность в том, что любимое решение разработчика универсально и применимо везде.
*   Изобретение колеса: ошибка адаптации существующего решения (создание своего с нуля, когда есть готовое).

### 5. Организационные и управленческие антипаттерны
*   Единственный знающий человек: когда критическая информация о системе сосредоточена у одного сотрудника, что делает проект зависимым от него.
*   Управление грибами: удержание работников в неинформированном состоянии.
*   Функции для галочки: разработка несвязных и плохо реализованных функций только ради заявления об их наличии.
*   Раздувание ПО: ситуация, когда каждая последующая версия программы требует всё больше ресурсов.
*   Рыцарь на белом коне: личность, которая исправляет ошибки в одиночку, не уведомляя остальных участников проекта о сделанных изменениях.

32.   Место базы данных в «чистой архитектуре» информационных систем.

Согласно лекционным материалам, место и роль базы данных (БД) в «чистой архитектуре» определяются следующими положениями:

*   Низкоуровневая деталь: С архитектурной точки зрения база данных не является сущностью — это всего лишь низкоуровневая конкретная деталь и утилита, обеспечивающая доступ к данным.
*   Принцип независимости: Бизнес-правила системы не должны быть привязаны к базе данных. Хороший архитектор не позволяет низкоуровневым механизмам «просачиваться» в архитектуру системы.
*   Изоляция внутренних слоев: Никакой код, находящийся во внутренних кольцах (кругах) архитектуры, не должен ничего знать о базе данных. О табличной организации данных должны знать только вспомогательные функции во внешних кольцах.
*   Разграничение данных и БД: Организационная структура и модель данных являются архитектурно значимыми элементами, в то время как сама база данных — нет.
*   Типичная ошибка: Передача записей и таблиц из БД в виде объектов через всю информационную систему считается архитектурной ошибкой, так как это жестко связывает варианты использования и интерфейс с конкретной реляционной структурой данных.

33.   Системная архитектура базы данных. Архитектура ANSI/SPARC.

Согласно лекционным материалам, системная архитектура базы данных на основе стандарта ANSI/SPARC (1975 г.) была одной из первых попыток создания централизованной архитектуры данных,.

### Основные положения архитектуры ANSI/SPARC

*   Главная цель: Обеспечение независимости данных. Это позволяет изменять структуру хранения данных без необходимости перестраивать всю информационную систему целиком.
*   Концепция разделения: Архитектура базируется на разделении описания данных на три независимые схемы (уровня), что освобождает разработчика логической модели от забот о файловых структурах,.

### Уровни (схемы) архитектуры

1.  Концептуальная схема (Conceptual Schema):
    *   Содержит логическое описание всей базы данных.
    *   В этой модели используется язык запросов (например, SQL).
    *   Является «мостом» между внешними приложениями и физическим хранилищем.

2.  Внутренняя схема (Internal Schema):
    *   Представляет реальную (физическую) структуру базы данных в памяти.
    *   Описывает способы сортировки полей, индексы и методы размещения данных на носителях.

3.  Внешний уровень (Интерфейсы):
    *   Определяет структуру и отображение интерфейсов между конкретным приложением и базой данных.

### Ключевые преимущества (Виды независимости)

*   Физическая независимость данных: Благодаря «отображению» (mapping) концептуальной модели во внутреннюю, изменения на физическом уровне (новые индексы, способы сортировки) не влияют на модели высокого уровня и работу приложений.
*   Логическая независимость: Возможность изменения концептуальной схемы без необходимости менять внешние схемы (представления пользователей).

### Состав архитектуры данных (согласно ANSI/SPARC):
1.  Язык доступа к данным (SQL).
2.  Схема концептуального проекта.
3.  Схема внутреннего (физического) проекта.
4.  Интерфейсы и механизмы отображения между ними.

34.   Реляционная модель данных.

Согласно лекционным материалам, основные положения о реляционной модели данных для экзамена:

Суть и структура
*   Отношение (Relation): Основной элемент модели — таблица, состоящая из строк и столбцов.
*   Элементы таблицы:
    *   Атрибуты: Столбцы с соответствующим типом данных.
    *   Первичный ключ (PK): Уникальный идентификатор строки.
    *   Внешний ключ (FK): Используется для связи между таблицами.

Нормализация
Это процесс создания оптимальной табличной структуры во избежание избыточности и аномалий.
*   1-я нормальная форма (1НФ): Все значения в полях должны быть атомарными (неделимыми/элементарными). 
*   2-я нормальная форма (2НФ): Соответствие 1НФ и зависимость всех неключевых атрибутов от первичного ключа.
*   3-я нормальная форма (3НФ): Неключевой атрибут зависит только от первичного ключа и ни от какого другого неключевого атрибута.
*   5-я нормальная форма (5НФ): Высшая форма нормализации. Достигается путем декомпозиции таблиц до тех пор, пока не исчезнут все зависимости, кроме зависимостей по полному первичному ключу.

Проектирование через UML
Современный подход (по Р. Мюллеру) предполагает, что использование объектно-ориентированного проектирования и диаграмм классов UML позволяет почти автоматически создавать нормализованные БД. 
*   Классы со стереотипом `«table»` становятся таблицами.
*   Ассоциация и агрегация отображаются как неидентифицирующие связи, а композиция — как идентифицирующая связь.
*   Операции классов (`pk`, `fk`, `uniq`, `index`) описывают ограничения целостности и триггеры.

Современные критерии выбора РБД
При создании реляционных БД сегодня ключевыми являются:
1.  Требования к производительности и скорости выполнения SQL-запросов.
2.  Объём хранимых данных и работа с Big Data.
3.  Сложность запросов и бюджет проекта.
4.  Требования регуляторов (например, импортозамещение и переход на системы на базе PostgreSQL).

35.   Подходы к оценке качества базы данных.

Согласно лекционным материалам, оценка качества базы данных (БД) проводится по нескольким ключевым направлениям:

### 1. Оценка размера и сложности
*   Размер БД и её схемы: оценка объема данных и сложности структуры.
*   Метод функциональных точек: бальная оценка функциональности на основе вариантов использования (Use Cases).
*   Формула для доменных систем: расчет объема (в Кб) на основе количества пользователей ($U_c$), компьютеров ($C_c$) и их членства в группах ($M_c$).

### 2. Оценка потенциала повторного использования
Выделяют три вида вероятности повторного использования:
*   Собственная способность: определяется степенью инкапсуляции (изоляции от других систем) и завершенностью программного интерфейса.
*   Доменная способность: вероятность того, что структура БД удовлетворит требованиям будущих систем в той же предметной области.
*   Организационная способность: наличие в организации правил и связей, способствующих повторному использованию.

### 3. Оценка производительности и оптимизации
*   Время реализации SQL-запроса: основной критерий оптимальности реляционной структуры.
*   Нормализация: процесс устранения избыточности и аномалий. Высшей формой считается 5-я нормальная форма, где отсутствуют любые зависимости, кроме как по полному первичному ключу.
*   Работа с Big Data: способность системы справляться с большими объемами данных и сложными запросами.

### 4. Тестирование и верификация
Для оценки качества в динамике применяются различные виды тестирования:
*   Стрессовое: проверка работы при большом числе транзакций в течение длительного времени.
*   Нагрузочное: обнаружение взаимных блокировок и проблем с очередями при работе множества клиентов.
*   Эффективности: получение количественных характеристик системы в реальном окружении.
*   Регрессионное: проверка сохранения работоспособности неизмененных частей после модификации.

### 5. Сертификация и гарантии качества
При передаче БД для повторного использования оцениваются:
*   Уровень риска: устанавливаются допуски, определяющие безопасность использования системы.
*   Системные гарантии: подтверждение производительности, целостности данных, совместимости и отсутствия нарушений авторских прав.
*   Синхронизация: проверка соответствия физической БД её CASE-модели и эталонному дистрибутиву.

36.   Потенциал повторного использования базы данных; его оценка и сертификация.

Согласно лекционным материалам, потенциал повторного использования базы данных (БД) и процессы его оценки включают следующие ключевые аспекты:

### 1. Виды потенциала повторного использования
Выделяют три составляющие вероятности повторного использования БД:
*   Собственная способность: обусловлена степенью инкапсуляции (отсутствием жестких связей с другими БД или временными классами) и завершенностью программного интерфейса.
*   Доменная способность: вероятность того, что структура и содержимое БД будут удовлетворять требованиям новых систем в той же предметной области в будущем.
*   Организационная способность: наличие в организации правил, стандартов и связей, способствующих повторному использованию.

### 2. Оценка потенциала
*   Взвешенная оценка: при анализе учитывается вклад каждого фактора. Если система узкоспециализирована, больший вес придается доменному фактору; если важна структура — собственной способности.
*   Принципы проектирования: для повышения потенциала применяются принципы ООП: параметризация, создание устойчивых хранилищ и классов с атрибутами, удобными для наследования.
*   Оценка размера (для доменных систем): используется формула для расчета объема: $Объём (Кб) = (U_c \times 50) + (C_c \times 20) + (M_c \times 1)$, где $U_c$ — пользователи, $C_c$ — компьютеры, $M_c$ — членства в группах.
*   Сложность схемы: может оцениваться методом функциональных точек на основе вариантов использования (Use Cases).

### 3. Сертификация БД для повторного использования
Процесс сертификации включает подтверждение готовности БД к внедрению в другие проекты:
*   Установление уровня риска: повторный пользователь задает критерии и допуски риска, определяющие допустимость использования системы.
*   Прозрачность структуры: представление четкой структуры системы через опубликованные модели данных (например, диаграммы UML), что дает полное описание БД.
*   Разграничение ответственности: письменное обозначение системы как повторно используемой и определение ответственных за её компоненты.
*   Системные гарантии: предоставление официальных гарантий качества, которые включают:
    *   Производительность;
    *   Совместимость;
    *   Целостность (отсутствие повреждений);
    *   Соблюдение авторских прав.

37.   Определение процесса нормализации данных.

Согласно лекционным материалам, определение и суть процесса нормализации данных заключаются в следующем:

*   Определение: Нормализация — это процесс установления оптимальной табличной структуры, основанный на анализе внутренних зависимостей данных.
*   Суть процесса: Структурирование таблиц и столбцов в схеме базы данных для избежания аномалий и определенных ограничений, возникающих из-за плохой структуры.
*   Критерий оптимальности: Одним из ключевых показателей качества нормализованной структуры является время реализации SQL-запроса.
*   Методика: Процесс реализуется как последовательный переход по нормальным формам. Высшей формой считается 5-я нормальная форма, которая достигается путем декомпозиции таблиц до тех пор, пока не будут устранены все зависимости, кроме зависимостей по полному первичному ключу.
*   Альтернативный взгляд: Согласно мнению Р. Мюллера, использование объектно-ориентированного проектирования и диаграмм классов UML позволяет создавать нормализованную базу данных практически сразу, так как идентификация объектов и иерархий классов сама по себе направлена на оптимизацию таблиц.

38.   Первая, вторая и третья нормальные формы.

Согласно лекционным материалам, нормализация представляет собой процесс установления оптимальной табличной структуры на основе анализа внутренних зависимостей данных для устранения аномалий.

Ниже приведены основные характеристики первых трех нормальных форм:

*   1-я нормальная форма (1НФ)  
    Все поля таблицы должны содержать атомарные (неделимые) значения; каждое значение в таблице должно быть элементарным. Согласно источникам, в стандартном реляционном SQL практически невозможно создать таблицу не в 1НФ, так как он не поддерживает многозначные типы данных (например, массивы объектов).

*   2-я нормальная форма (2НФ)  
    Таблица должна соответствовать требованиям 1НФ, и при этом все неключевые атрибуты должны зависеть от первичного ключа.

*   3-я нормальная форма (3НФ)  
    Таблица должна находиться во 2НФ, при этом каждый неключевой атрибут должен зависеть только от первичного ключа и не зависеть от любого другого неключевого атрибута.

В источниках также отмечается мнение Роберта Мюллера, согласно которому использование объектно-ориентированного подхода и нотации UML (создание связных иерархий классов) позволяет практически автоматически создавать нормализованные базы данных, избегая проблем со структурными зависимостями.

39.   Нормальная форма Бойса-Кодда.

Согласно лекционным материалам, основные сведения о нормальной форме Бойса-Кодда (BCNF) для экзамена:

*   Определение: Для каждой функциональной зависимости в таблице должен существовать суперключ, определяемый этой зависимостью.
*   Суть: BCNF является более строгим вариантом третьей нормальной формы (3НФ).
*   Цель применения: Устранение аномалий и структурных зависимостей, возникающих из-за некачественного проектирования схемы базы данных.
*   Контекст в лекциях: 
    *   Создатель реляционной теории Эдгар Кодд структурировал нормализацию как последовательный переход по формам. 
    *   Отмечается мнение (Р. Мюллера), что применение объектно-ориентированного проектирования и диаграмм классов UML позволяет почти автоматически создавать нормализованные БД, минуя необходимость детального ручного разбора каждой формы, так как иерархии классов уже направлены на оптимизацию таблиц.

40.   Опишите факторы, влияющие на выбор системы управления базами данных.

Согласно лекционным материалам, при выборе системы управления базами данных (СУБД) ключевыми факторами и критериями являются:

1.  Требования к производительности: оценивается скорость выполнения операций, в частности, время реализации SQL-запросов,.
2.  Объём хранимых данных: способность системы эффективно работать с большими данными (Big Data).
3.  Сложность запросов: необходимость поддержки сложных транзакций и аналитических выборок,.
4.  Бюджет проекта: финансовые ограничения на приобретение лицензий и обслуживание системы.
5.  Требования регуляторов: соблюдение законодательства, в том числе в части импортозамещения. В современных российских условиях это дает преимущество СУБД, построенным на движке PostgreSQL.
6.  Функциональные особенности и архитектура:
    *   Наличие открытого исходного кода (например, PostgreSQL).
    *   Масштабируемость и простота настройки (например, MySQL/MariaDB).
    *   Гибкость настройки структуры документов (например, MongoDB для неструктурированных данных).
    *   Поддержка различных платформ.

Для государственных и крупных российских организаций фактор нормативных требований (импортозамещения) зачастую является определяющим при выборе технологического стека.

41.   Перечислите и подробно опишите этапы проектирования базданных.

Согласно лекционным материалам, процесс проектирования баз данных (БД) можно разделить на несколько ключевых этапов, основываясь на классической архитектуре ANSI/SPARC и современном объектно-ориентированном подходе (UML).

1. Выделение процессов и требований (Анализ)
*   Суть: Определение границ системы и действий пользователей.
*   Инструменты: Диаграммы вариантов использования (Use Case Diagrams) для описания того, что система должна делать.

2. Концептуальное проектирование (Логическая модель)
*   Суть: Декомпозиция предметной области, идентификация сущностей (понятий), их атрибутов и связей между ними.
*   Инструменты: Диаграммы объектов (Object Diagrams) и диаграммы классов (Class Diagrams).
*   Особенности: На этом этапе создается концептуальная схема, которая содержит логическое описание всей БД и не зависит от физического способа хранения.

3. Логическое проектирование и нормализация
*   Суть: Преобразование объектной модели в реляционную структуру (таблицы) и её оптимизация.
*   Основные действия:
    *   Отображение классов в таблицы (стереотип `«table»`), атрибутов — в столбцы, ассоциаций — в связи.
    *   Нормализация: последовательный переход от 1НФ к 5НФ для устранения избыточности и аномалий.
    *   *Примечание:* Согласно лекциям, использование UML-диаграмм позволяет получить нормализованную структуру практически автоматически.

4. Внутреннее (физическое) проектирование
*   Суть: Описание реальной структуры базы данных в памяти устройства.
*   Содержание: Определение методов сортировки данных, создание индексов, выбор способов размещения данных на носителях для повышения производительности.

5. Реализация и генерация схемы
*   Суть: Физическое создание БД и настройка интерфейсов.
*   Инструменты: Использование CASE-средств для автоматической генерации SQL-запросов и создания структуры таблиц на основе моделей.
*   Результат: Компонент со стереотипом `«database»`, представляющий физическую БД.

Итог для экзамена: Проектирование идет от анализа вариантов использования к концептуальной модели (UML), затем к логической структуре (таблицы и нормализация) и завершается физическим описанием (индексы) и генерацией SQL-кода.

42.   Определение распределённой информационной системы.

Согласно лекционным материалам, распределённая система — это система, состоящая из множества автономных узлов, которые работают совместно над решением общей (определенной) задачи,.

Основные характеристики для экзамена:

*   Масштабируемость: возможность горизонтального расширения ресурсов практически до бесконечности в зависимости от архитектуры,.
*   Надёжность: отказ отдельного узла не оказывает критического влияния на функционирование всей системы в целом,.
*   Высокая доступность: обеспечивается за счёт резервирования серверов,.
*   Сложности реализации: основными проблемами таких систем являются синхронизация времени, синхронизация данных (репликация) и обеспечение их целостности,,.

43.   Преимущества и недостатки микросервисного подхода.

Согласно лекционным материалам, микросервисный подход предполагает построение приложений в виде набора небольших, слабосвязанных сервисов, каждый из которых работает в своем процессе и общается с другими через простые механизмы,.

Достоинства (преимущества):
*   Гибкость архитектуры: каждый сервис может разрабатываться небольшой командой и развертываться независимо от других,.
*   Легкость модификации: системы на базе микросервисов проще изменять и дорабатывать,.
*   Повторное использование: микросервисы рассматриваются как компоненты, ориентированные на многократное использование,.
*   Технологическая независимость: разные сервисы могут создаваться на разных языках программирования разными командами,.

Недостатки:
*   Снижение скорости: микросервисы проигрывают монолитам в быстродействии, что ограничивает их использование в системах реального времени,.
*   Сложность управления: процесс управления системой, состоящей из большого количества сервисов, становится трудной задачей,.
*   Проблемы транзакций: возникают значительные трудности при реализации действий в рамках единой транзакции,.
*   Трудоемкое тестирование: существенно увеличиваются затраты на проведение интеграционных тестов,.
*   Отсутствие единой теории: разделение системы на сервисы остается «искусством», требующим большого опыта проектировщика и серьезной предварительной работы,.

44.   Ограничения микросервисной архитектуры.

Согласно лекционным материалам, микросервисная архитектура имеет ряд существенных ограничений и недостатков:

*   Снижение производительности: Микросервисы проигрывают в скорости работы монолитным системам, что ограничивает их применение в системах реального времени,.
*   Сложность управления: Организация и администрирование системы, состоящей из большого количества независимых сервисов, является трудной задачей,.
*   Проблема транзакций: Существуют значительные трудности при реализации бизнес-логики в рамках единой транзакции между разными сервисами,.
*   Высокие затраты на тестирование: Существенно увеличиваются трудозатраты и стоимость проведения интеграционных тестов,.
*   Отсутствие единых стандартов проектирования: Нет общепринятой теории построения таких систем. Разбиение приложения на сервисы остается «искусством», требующим большого опыта проектировщика и серьезной предварительной работы,.
*   Проблемы распределенных систем: Как и любая распределенная система, она сталкивается с проблемами синхронизации (времени и данных), обеспечением целостности данных и повышенной нагрузкой на сеть,,,.

45.   Определение сервисы в контексте распределённой информационной системы.

Согласно лекционным материалам, определение и ключевые характеристики сервиса в контексте распределенных систем:

Определение
*   Сервис — это любая дискретная (конечная) функция, которая может быть предложена внешнему потребителю,. 
*   В качестве сервиса может выступать как отдельная бизнес-функция, так и набор функций, образующий целый бизнес-процесс,.

Ключевые свойства сервисов
*   Многократное использование: сервисы представляют собой функции, ориентированные на повторное применение в разных частях системы или разными потребителями,.
*   Формальные интерфейсы: сервисы определяются через интерфейсы, которые не зависят от конкретной технической реализации самого сервиса,.
*   Инвариантность (независимость): обращение к сервису не зависит от используемого языка программирования или аппаратной платформы,.

Роль в распределенной (микросервисной) архитектуре
В современных распределенных системах приложения строятся как набор небольших, слабосвязанных сервисов, где каждый:
*   Работает в своем собственном процессе,.
*   Взаимодействует с другими сервисами через простые механизмы (протоколы),.
*   Является независимым при развертывании и масштабировании,.

46.   Системы хранения данных в распределённых информационных системах.

Согласно лекционным материалам, современные системы хранения данных (СХД) в распределенных ИС строятся на принципах абстрагирования и кластеризации.

### 1. Программно-определяемое хранилище (SDS — Software Defined Storage)
Это основная тенденция развития СХД.
*   Суть: Объединение простых и доступных систем в кластерные структуры с помощью специализированного ПО.
*   Цель: Абстрагирование логики хранения от физического оборудования. Функции реализуются программно на стандартных устройствах.
*   Особенности: Типовые серверы становятся слоем блочного, файлового или объектного хранения. Однако аппаратная независимость частично «иллюзорна»: скорость операций всё равно зависит от наличия SSD или HDD.

### 2. Типы и форматы хранения
*   Блочный формат (raw): Обеспечивает высокую скорость операций ввода-вывода. Оптимален для баз данных.
*   Файловый формат (напр., qcow2): Обеспечивает надежное сохранение и разнообразие форматов виртуальных машин.
*   Объектное хранилище: Управляет данными на уровне объектов (данные + метаданные + уникальный ID). 
    *   Хорошо подходит для неструктурированных данных.
    *   Равномерно распределяет данные между узлами, исключая точки отказа.
    *   *Примеры:* Ceph, Cluster FS.

### 3. Механизмы обеспечения надежности
*   Репликация (синхронизация данных): Используется для обеспечения целостности и надежности. 
*   Выбор схемы: Зависит от того, где скорость выше — в сети или на устройстве ввода-вывода. 
*   Издержки: Репликация увеличивает нагрузку на сеть и требует дополнительного дискового пространства.

### 4. Сетевые решения
При наличии быстрой сети могут использоваться кластерные системы NAS (протоколы NFS, CIFS). Для обеспечения целостности данных в распределенных средах также задействуются специализированные файловые системы и сетевые протоколы (например, NTFS в контексте Windows-сред).

47.   Распределенные кластерные файловые системы.

Согласно лекционным материалам, распределенные кластерные файловые системы являются частью концепции программно-определяемого хранилища (SDS), где логика управления данными отделена от физического оборудования.

Основные положения для экзамена:

*   Принцип организации: объединение простых и доступных вычислительных узлов в кластерные структуры с помощью специализированного ПО, которое обеспечивает независимость каждого узла и общую отказоустойчивость.
*   Типы систем:
    *   Объектное хранилище: в отличие от традиционных систем, управляет данными на уровне объектов (данные + метаданные + уникальный ID). Оно позволяет равномерно распределять данные между узлами, исключая «точки отказа» в виде выделенных серверов метаданных.
    *   Файловый формат (например, qcow2): обеспечивает надежное сохранение данных и поддержку различных форматов виртуальных машин.
    *   Кластерные системы NAS: используют сетевые протоколы (NFS, CIFS) при наличии высокоскоростных каналов связи.
*   Примеры реализаций: Ceph, Cluster FS.

Преимущества и особенности:
*   Масштабируемость: возможность практически неограниченного горизонтального расширения ресурсов.
*   Надежность: отказ отдельного узла не приводит к остановке всей системы.
*   Целостность данных: обеспечивается за счет механизмов репликации и использования специализированных файловых систем.

Проблемы (недостатки):
*   Синхронизация: необходимость постоянной синхронизации данных между узлами, что создает высокую нагрузку на сеть и требует дополнительного дискового пространства.
*   Доступ к метаданным: в распределенных объектных системах может потребоваться обращение к каждому узлу для получения метаданных, что иногда делает выделенный сервер метаданных более эффективным решением при наличии быстрой сети.

48.   Определение процесса тестирования программных средств.

Согласно лекционным материалам, тестирование программного обеспечения — это процесс проверки функциональности продукта, выявления ошибок и его несоответствия установленным требованиям.

Уровни тестирования:
*   Юнит-тесты (Unit tests): проверка отдельных компонентов системы (методов или классов); это низший уровень, обеспечивающий правильность реализации базового функционала модулей.
*   Интеграционные тесты: проверка взаимодействия программных модулей друг с другом и работоспособности системы на уровне их интеграции.
*   End-to-End тесты (E2E): полное воспроизведение действий пользователей для проверки всей системы от начала до конца, включая симуляцию реальных сценариев использования.

Подходы к организации автоматизированного тестирования:
*   TDD (Test Driven Development): сначала создается тест, а затем пишется код для его прохождения.
*   BDD (Behavior Driven Development): создание спецификаций поведения системы, основанных на примерах реального использования.
*   CI/CD: интеграция тестов в процессы непрерывной сборки и доставки для раннего выявления дефектов.

Принципы проектирования тестов:
1.  Модульность и независимость тестов.
2.  Использование шаблонов (например, Page Object Model) для упрощения поддержки.
3.  Организация стабильных и повторяемых окружений для тестирования.

49.   Перечислите и подробно опишите виды тестирования программных средств.

Согласно лекционным материалам, виды и уровни тестирования программных средств классифицируются следующим образом:

### Основные уровни тестирования
1.  Юнит-тесты (Unit tests): тестирование отдельных компонентов системы (операций или методов классов). Это низший уровень, обеспечивающий проверку правильности реализации базового функционала каждого модуля.
2.  Интеграционные тесты: проверка взаимодействия программных модулей друг с другом и работоспособности системы на уровне интеграции частей приложений.
3.  End-to-End тесты (E2E): полное воспроизведение действий пользователей для проверки всей системы от начала до конца, включая симуляцию реальных сценариев использования.

### Виды тестирования (для систем архитектуры клиент-сервер)
*   Функциональное тестирование: базовый вид контроля, заключающийся в проверке функциональности операций на единственном экземпляре приложения. Используется как основа в других видах тестирования.
*   Конфигурационное тестирование: проверка работы приложения во всех комбинациях платформ клиента и сервера.
*   Конкурентное тестирование: проверка способности сервера одновременно обслуживать двух и более клиентов.
*   Стрессовое тестирование: проверка на большом числе транзакций в течение длительного времени для обнаружения ошибок в динамике.
*   Тестирование нагрузки: верификация работы большого числа конкурирующих клиентов для обнаружения взаимных блокировок и проблем с очередями. Бывает двух видов: выборочное (короткая загрузка данных одного типа) и комплексное (проверка системы в режиме ввода и проверки данных).
*   Тестирование эффективности: получение количественных характеристик системы с учетом её работы в реальном окружении.
*   Регрессионное тестирование: проверка сохранения работоспособности и независимости тех частей системы, которые не подвергались модификации после внесения изменений.

### Процедуры при формировании дистрибутива
Помимо основных видов, лекции выделяют специфические процедуры контроля:
*   Тестирование и отладка на рабочих местах разработчиков.
*   Верификация исходных тестов измененных модулей.
*   Синхронизация CASE-модели базы данных и её физической реализации.
*   Стендовые комплексные испытания на данных, максимально приближенных к реальным.

50.   Уровни тестирования программных средств.

Согласно лекционным материалам, выделяют три основных уровня тестирования программных средств в общем виде:

1.  Unit-тесты (модульное тестирование):
    *   Суть: Тестирование отдельных компонентов системы (конкретных операций или методов классов).
    *   Назначение: Является низшим уровнем тестирования; обеспечивает проверку правильности реализации базового функционала каждого отдельного модуля.

2.  Интеграционные тесты:
    *   Суть: Проверка взаимодействия программных модулей друг с другом.
    *   Назначение: Проверка работоспособности системы на уровне интеграции (связки) различных частей приложений.

3.  End-to-End тесты (E2E):
    *   Суть: Полное воспроизведение действий пользователей для проверки системы от начала до конца.
    *   Назначение: Верификация работоспособности всей системы в целом, часто с помощью симулирования реальных сценариев использования продуктов.

51.   Инструментальные средства автоматического тестирования веб-приложений.

Согласно лекционным материалам, для автоматизации тестирования веб-приложений используются специализированные фреймворки и инструменты, разделенные по экосистемам и назначению:

1. Инструменты непосредственно для веб-тестирования (UI/E2E):
*   Selenium:
    *   Особенности: кроссплатформенность, взаимодействие напрямую с браузером,.
    *   Применение: проверка форм ввода и кнопок, автоматизация UI и API тестов,.
    *   Преимущества: поддержка различных языков программирования,.
*   Cypress (Сайкрос):
    *   Особенности: синхронность исполнения команд и встроенная поддержка мокинга (Mocking) HTTP-запросов,.
    *   Применение: написание UI-тестов, реализация End-to-End сценариев (загрузка страниц, навигация по сайту),.

2. Фреймворки в экосистеме JavaScript и TypeScript:
*   Jest: универсальный фреймворк для unit-тестирования, также поддерживающий интеграционные и элементы End-to-End тестов,.
*   Mocha (Мокко): инструмент для модульного тестирования; преимущество — легкость организации структуры тестовых сценариев,. Поддерживает подход TDD,.

3. Фреймворки в экосистеме Python:
*   PyTest: универсальное средство для всех видов тестирования,.
*   Преимущества: простой синтаксис и поддержка параметризованных тестов,.

Общие принципы использования инструментов:
Автоматизация часто интегрируется в процессы CI/CD для раннего выявления дефектов и основывается на паттернах, таких как Page Object Model, для упрощения поддержки элементов интерфейса,,,.

52.   Определение и описание аппаратной виртуализации, программной виртуализации и паравиртуализации.

Виртуализация — это процесс, обеспечивающий работу нескольких операционных систем на базе совместного использования одного и того же аппаратного обеспечения. Прослойка, реализующая этот процесс, называется гипервизором.

Согласно источникам, выделяют следующие виды виртуализации:

1.  Программная виртуализация
    *   Суть: Заключается в полной эмуляции аппаратного обеспечения.
    *   Пример: Приложение QEMU.
    *   Особенность: В сравнении с другими технологиями (например, контейнеризацией) имеет существенно более высокие накладные расходы из-за необходимости эмуляции.

2.  Аппаратная виртуализация
    *   Суть: Использует специальные возможности центрального процессора, которые позволяют не эмулировать его инструкции. Происходит изоляция ресурсов процессора для каждой виртуальной машины.
    *   Ограничение: Жесткая привязка к архитектуре ЦП (например, на процессоре архитектуры ARM можно запустить только гостевые системы ARM).
    *   Пример: QEMU-KVM.

3.  Паравиртуализация
    *   Суть: Из процесса эмуляции исключаются не только центральный процессор, но и система ввода-вывода. Это достигается за счет использования специализированных драйверов.
    *   Пример: QEMU + VirtIO.


53.   Особенности контейнеризации. Преимущества и недостатки контейнеризации.

Контейнеризация — это вид виртуализации, который условно разделяют на виртуализацию ОС и виртуализацию приложений.

### Особенности контейнеризации
*   Общее ядро: Ядро операционной системы является общим как для хост-системы, так и для контейнера.
*   Отсутствие эмуляции: В отличие от классической виртуализации, здесь полностью отсутствует эмуляция аппаратного обеспечения.
*   Изоляция процессов: Контейнер представляет собой изолированный «пучок» (ветку) процессов, работающих в уникальном пространстве имен.
*   Управление: Группами процессов в контейнере можно управлять как единым целым.
*   Легкость развертывания: Создание контейнера (например, LXC) происходит из шаблона, который уже содержит проинсталлированную ОС, что исключает необходимость создания отдельной сущности в виде виртуальной машины.

### Преимущества
*   Низкие накладные расходы: Благодаря отсутствию эмуляции ресурсов, контейнеризация потребляет значительно меньше мощностей по сравнению с программной виртуализацией.
*   Высокая скорость: Запуск и работа процессов происходят быстрее, так как они выполняются непосредственно на ядре хоста.
*   Эффективность: Позволяет более плотно распределять нагрузку на серверные мощности.

### Недостатки
*   Зависимость от ядра: Операционная система контейнера должна быть идентична хостовой ОС (использовать то же ядро).
*   Риски безопасности: При использовании привилегированных контейнеров имеется возможность выполнять действия в наружной (хостовой) системе, что не рекомендуется для обеспечения безопасности.

54.   Область применения технологии виртуализации.

Технология виртуализации применяется в следующих основных областях:

*   Тестирование программного обеспечения.
*   Обучение.
*   Повышение эффективности использования серверных мощностей за счет более комплексного и рационального распределения нагрузки и ресурсов.
*   Поддержка работы унаследованных (legacy) приложений, требующих специфических или устаревших операционных сред.

55.   Особенности выполнения процессов в контейнере.

Особенности выполнения процессов в контейнере (по материалам лекций):

*   Использование общего ядра: Все процессы контейнера выполняются непосредственно на ядре хост-системы.
*   Ветка процессов: В отличие от виртуальной машины, которая для хоста выглядит как один большой процесс, контейнер представляет собой изолированную ветку (или «пучок») процессов.
*   Изоляция через пространства имен: Для процессов контейнера создается уникальное пространство имен, что обеспечивает их изоляцию от других процессов в системе.
*   Отсутствие эмуляции: Процессы работают без эмуляции аппаратного обеспечения, что существенно снижает накладные расходы на их выполнение.
*   Единое управление: Группами процессов в контейнере можно управлять как единым целым.
*   Уровни привилегий: 
    *   В непривилегированных контейнерах пользователи внутри не соответствуют пользователям хоста (безопасный режим).
    *   В привилегированных контейнерах процессы имеют права root хостовой системы, что позволяет им выполнять действия во внешней системе (не рекомендуется).

56.   Привилегированные и непривилегированные контейнеры.

В контексте технологии контейнеризации (на примере LXC) выделяют два типа контейнеров:

*   Непривилегированные контейнеры
    *   Суть: Пользователи внутри такого контейнера не соответствуют пользователям хостовой системы.
    *   Безопасность: Считаются безопасными, так как действия внутри контейнера ограничены его средой.

*   Привилегированные контейнеры
    *   Суть: Владельцем процессов внутри контейнера является root хостовой системы.
    *   Особенность: Позволяют выполнять действия не только внутри контейнера, но и в наружной (хостовой) системе.
    *   Рекомендация: Использование таких контейнеров не рекомендуется из-за высоких рисков безопасности.

57.   Виртуализация приложений. Архитектура Docker.

Виртуализация приложений (рассматриваемая в источниках как часть контейнеризации) — это метод, при котором ядро операционной системы является общим для хост-системы и виртуализируемой среды.

### Архитектура и ключевые особенности (по лекциям):

*   Использование общего ядра: Процессы контейнера выполняются непосредственно на ядре хоста.
*   Изоляция через пространства имен: Для процессов создается уникальное пространство имен, что обеспечивает их логическую изоляцию от остальной системы.
*   Отсутствие эмуляции: В архитектуре контейнеризации полностью отсутствует эмуляция аппаратного обеспечения, что значительно снижает накладные расходы.
*   Контейнер как ветка процессов: В отличие от виртуальной машины, которая видится хостом как один массивный процесс, контейнер — это изолированный «пучок» (ветка) процессов.
*   Групповое управление: Группы процессов в рамках этой архитектуры управляются как единое целое.
*   Развертывание через шаблоны: Создание среды (на примере LXC) происходит из шаблона, который уже содержит готовую проинсталлированную ОС, что исключает необходимость создания отдельной виртуальной сущности.

Преимущество такой архитектуры: Высокая эффективность и минимальные затраты ресурсов по сравнению с программной виртуализацией.

*Примечание: В предоставленных источниках конкретные внутренние компоненты Docker (Docker Engine, Daemon и др.) не упоминаются; описание архитектуры дано на базе общих принципов контейнеризации и технологии LXC.*

58.   Назначение и отличительные особенности системы управления конфигурациями Ansible.

Ansible — это система управления конфигурациями, предназначенная для автоматизации ИТ-инфраструктуры,.

### Назначение Ansible
*   Автоматизация конфигурирования и развертывания программного обеспечения,.
*   Централизованное удаленное управление разнородной информационной инфраструктурой,.
*   Параметризация процессов с помощью сценариев (плейбуков),.
*   Управление с обратной связью на основе сбора фактов о состоянии систем,.

### Отличительные особенности
*   Безагентная архитектура (Agentless): Не требует установки специального программного обеспечения (агентов) на управляемые узлы,.
*   Push-модель управления: Управляющий узел сам инициирует передачу конфигураций и команд на целевые хосты (в отличие от pull-модели, как в Puppet),.
*   Декларативный синтаксис (YAML): Описывается целевое состояние узла (что должно быть в итоге), а не последовательность конкретных команд,.
*   Параллельное выполнение: Возможность одновременного внесения изменений на множестве узлов,.
*   Транспортный протокол: Сетевое взаимодействие осуществляется через стандартную службу SSH,.

### Ключевые компоненты архитектуры
*   Управляющий узел: Хост, с которого запускаются модули,.
*   Модули: Небольшие программы на Python (выполняются на управляемых узлах для приведения их в нужное состояние),.
*   Playbooks (Плейбуки): Сценарии на языке YAML, содержащие наборы задач,.
*   Роли: Наборы файлов (задачи, шаблоны, переменные), позволяющие декомпозировать сложные плейбуки и повторно использовать код,.
*   Ad-hoc команды: Однострочные команды для быстрого выполнения задач без написания сценариев,.

59.   Архитектура Ansible.

Архитектура Ansible строится на базе безагентного взаимодействия и push-модели управления,.

### Основные компоненты архитектуры:

1.  Управляющий узел (Control Host):
    *   Центральный хост, на котором установлена система и запускаются модули,.
    *   С него инициируется передача конфигураций на целевые системы,.

2.  Управляемые узлы (Managed Hosts):
    *   Целевые системы, которые приводятся в требуемое состояние,.
    *   Особенность: Не требуют установки специального агентского ПО (Agentless),. Для работы модулей на них необходим только Python с минимальным набором библиотек,.

3.  Сетевое взаимодействие:
    *   Связь осуществляется через стандартные службы и протоколы SSH,.

4.  Файлы инвентаризации (Inventory):
    *   Содержат списки и группы управляемых хостов, а также переменные для управления ими,.

5.  Модули (Modules):
    *   Небольшие параметризируемые программы (обычно на Python), которые передаются на управляемые узлы и выполняются там для реализации конкретных задач,.

6.  Плейбуки (Playbooks):
    *   Сценарии на языке YAML, представляющие собой декларативное описание целевой конфигурации узлов (наборы задач),,.

### Средства организации кода:

*   Роли (Roles): Структурированные наборы файлов (задачи, шаблоны, переменные), предназначенные для декомпозиции сложных плейбуков и повторного использования кода,.
*   Ad-hoc команды: Однострочные команды для быстрого выполнения задач без написания полноценных сценариев,.

60.   Ad-hoc команды и модули Ansible. Цветовой вывод Ansible.

### Ad-hoc команды
Ad-hoc команды — это однострочные команды, предназначенные для выполнения конкретных задач без написания полноценных сценариев (плейбуков).

*   Назначение: управление службами и процессами, проверка системных параметров, просмотр содержимого файлов (логов), проверка установленного ПО и изучение новых модулей.
*   Синтаксис: `ansible [-i inventory] [-m module] [-a "параметры"] [-b] [all|group|host]`.
    *   `-i` — путь к файлу инвентаризации (по умолчанию `/etc/ansible/hosts`).
    *   `-m` — название используемого модуля.
    *   `-a` — аргументы (параметры) модуля.
    *   `-b` — повышение привилегий (become).

### Модули Ansible
Модули — это небольшие параметризируемые программы (обычно на Python), которые являются основным инструментом управления узлами. Они передаются с управляющего узла на управляемые хосты для приведения их в требуемое состояние.

Основные модули:
*   `ping`: проверка доступности узла и наличия связи.
*   `copy`: копирование файлов на удаленные узлы.
*   `apt`, `dnf`, `apt_rpm`: установка и управление пакетами в различных ОС.
*   `shell`: выполнение произвольных команд через оболочку.
*   `lineinfile`, `replace`: вставка, удаление или замена строк в файлах.

### Цветовой вывод Ansible
Ansible использует цветовую индикацию для отображения результатов выполнения задач:
*   Зеленый: задача выполнена успешно, изменений в системе не произошло (например, подтверждение связи или состояние уже соответствует заданному).
*   Желтый: задача выполнена успешно, в систему внесены изменения (например, установлен пакет или обновлен файл).
*   Красный: произошла ошибка при выполнении задачи.

61.   Правила написания и структура рецептов (плейбуков) Ansible.

Рецепты (плейбуки) в Ansible — это декларативное описание целевой конфигурации управляемых узлов, составленное на языке YAML.

### Правила написания (синтаксис YAML)
*   Использование дефиса: начало перечислений, списков задач и управляемых хостов всегда помечается дефисом (`-`).
*   Отступы: выполняются строго только пробелами. Использование табуляции (Tab) запрещено.
*   Иерархия: элементы одного списка должны иметь одинаковый уровень отступа.
*   Редакторы: наиболее подходящими инструментами для написания считаются текстовые редакторы vim и geany.

### Структура плейбука
Плейбук имеет иерархическую структуру, состоящую из «игр» (plays) и задач (tasks):

1.  Play (Игра): определяет контекст выполнения.
    *   `hosts`: указывает, на каких узлах или группах из инвентаря выполнять сценарий.
    *   `become`: параметр для повышения привилегий (например, до root).
2.  Tasks (Задачи): список конкретных действий, выполняемых последовательно.
    *   `name`: краткое текстовое описание задачи (для удобства чтения логов).
    *   Модуль: название вызываемого модуля (например, `apt_rpm`, `copy`, `shell`).
    *   Параметры модуля: аргументы, определяющие состояние (например, имя пакета и его состояние `state: present`).

Пример простейшей структуры:
```yaml
- hosts: all
  become: yes
  tasks:
    - name: install package
      apt_rpm:
        name: some_package
        state: present
```

62.   Роли Ansible. Структура ролей.

Роль Ansible — это структурированный набор файлов, который содержит задания (tasks), шаблоны, переменные и другие компоненты, служащие единой цели (например, развертыванию или настройке конкретного программного средства).

### Назначение ролей
*   Повторное использование кода: возможность использовать одну и ту же логику в разных проектах.
*   Декомпозиция: разделение больших и сложных плейбуков на более мелкие, логические части.

### Структура каталога роли
Стандартная роль включает в себя следующие подкаталоги:
*   defaults — переменные по умолчанию для роли, которые могут быть легко перезаписаны в плейбуке.
*   vars — переменные роли, которые не предназначены для перезаписи.
*   tasks — основной набор задач, выполняемых ролью.
*   handlers — набор обработчиков (например, для перезапуска служб при изменении конфигов).
*   templates — шаблоны Jinja2, используемые для генерации конфигурационных файлов.
*   files — статические файлы, которые копируются на управляемые узлы «как есть».
*   tests — файлы инвентаризации и дополнительные плейбуки для тестирования самой роли.
*   meta — метаданные роли: информация об авторе, лицензии и зависимостях от других ролей.

При создании роли также автоматически генерируется файл README.md с описанием.



